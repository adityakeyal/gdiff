<html>

<head>
	<style type="text/css">
		ins{background-color:green;}
		del{background-color:red;}
	
	</style>
</head>
<body>
<h1>CustomerSightConnection.java</h1>
//$Id: CustomerSightConnection.java,v 1.1.2.3.2.3.46.2 2018/03/26 13:20:21 adityak Exp $
<br/>//$Revision: 1.1.2.3.2.3.46.2 $
<br/>//$Date: 2018/03/26 13:20:21 $
<br/>
<br/>/*
<br/> * +=======================================================================+
<br/> * |                                                                       |
<br/> * |          Copyright (C) 2000-2004 Nomura Securities Co., Ltd.          |
<br/> * |                          All Rights Reserved                          |
<br/> * |                                                                       |
<br/> * |    This document is the sole property of Nomura Securities Co.,       |
<br/> * |    Ltd. No part of this document may be reproduced in any form or     |
<br/> * |    by any means - electronic, mechanical, photocopying, recording     |
<br/> * |    or otherwise - without the prior written permission of Nomura      |
<br/> * |    Securities Co., Ltd.                                               |
<br/> * |                                                                       |
<br/> * |    Unless required by applicable law or agreed to in writing,         |
<br/> * |    software distributed under the License is distributed on an        |
<br/> * |    &#34;AS IS&#34; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,       |
<br/> * |    either express or implied.                                         |
<br/> * |                                                                       |
<br/> * +=======================================================================+
<br/> */
<br/>
<br/>package com.nri.xenos.th.inf.customersight;
<br/>
<br/>import java.net.URI;
<br/>import java.sql.Connection;
<br/>import java.sql.SQLException;
<br/>import java.text.ParseException;
<br/>import java.text.SimpleDateFormat;
<br/>import java.util.Calendar;
<br/>import java.util.Date;
<br/>import java.util.List;
<br/>
<br/>import org.apache.commons.dbutils.DbUtils;
<br/>import org.apache.commons.logging.Log;
<br/>import org.apache.commons.logging.LogFactory;
<br/>import org.springframework.http.HttpEntity;
<br/>import org.springframework.http.HttpMethod;
<br/>import org.springframework.http.HttpStatus;
<br/>import org.springframework.http.ResponseEntity;
<br/>import org.springframework.util.MultiValueMap;
<br/>import org.springframework.web.client.HttpClientErrorException;
<br/>import org.springframework.web.client.RestClientException;
<br/>import org.springframework.web.client.RestTemplate;
<br/>
<br/>import com.google.gson.JsonElement;
<br/>import com.google.gson.JsonParser;
<br/>import com.nri.xenos.Globals;
<br/>import com.nri.xenos.inf.Endpoint;
<br/>import com.nri.xenos.inf.Module;
<br/>import com.nri.xenos.inf.NoRecordFoundException;
<br/>import com.nri.xenos.inf.dbutils.QueryBuilderUtils;
<br/>import com.nri.xenos.inf.exception.RestConnectionException;
<br/>import com.nri.xenos.inf.ext.RESTConnection;
<br/>import com.nri.xenos.inf.ext.Response;
<br/>import com.nri.xenos.ref.Constants;
<br/>import com.nri.xenos.ref.entconfig.RefEnterpriseConfiguration;
<br/>import com.nri.xenos.ref.ext.ExtSysLock;
<br/>import com.nri.xenos.ref.rest.RESTAuditLog;
<br/>import com.nri.xenos.startup.Application;
<br/>import com.nri.xenos.th.inf.customersight.request.AbstractCSRequest;
<br/>import com.nri.xenos.th.inf.customersight.request.AbstractLoggedInCSRequest;
<br/>import com.nri.xenos.th.inf.customersight.service.CustomerSightLoginService;
<br/>
<br/>
<br/>/**
<br/> * 
<br/> * Concrete Implementation contains the logic to connect to Customer Sight. The
<br/> * implementation provides the below functionalities:
<br/> * 
<br/> * &lt;ul&gt;
<br/> * &lt;li&gt;Login to the Customer Sight API&lt;/li&gt;
<br/> * &lt;li&gt;Fetch the access token&lt;/li&gt;
<br/> * &lt;li&gt;Populate the access token to the incoming request&lt;/li&gt;
<br/> * &lt;li&gt;Connect to Customer Sight API&lt;/li&gt;
<br/> * &lt;/ul&gt;
<br/> * 
<br/> * &lt;br/&gt;
<br/> * &lt;br/&gt;
<br/> * 
<br/> * This class fetch the access token and stores in the database. In our case
<br/> * once access token fetched successfully then we want this token must persist
<br/> * in the database. For this reason in this class
<br/> * {@link #execute(AbstractLoggedInCSRequest)} api used non transacted
<br/> * connection (If we use transacted connection then it may happen after fetching
<br/> * the token some other error occurs, in such case we will lost the token).
<br/> * 
<br/> * &lt;br/&gt;
<br/> * &lt;br/&gt;
<br/> * 
<br/> * @version $Revision: 1.1.2.3.2.3.46.2 $, $Date: 2018/03/26 13:20:21 $
<br/> * @author adityak
<br/> * @author soumyadipd
<br/> *
<br/> */
<br/>public class CustomerSightConnection&lt;T&gt; implements RESTConnection&lt;AbstractLoggedInCSRequest&lt;T&gt;,String&gt; {
<br/>	
<br/>	private static final Log LOGGER = LogFactory.getLog(CustomerSightConnection.class);
<br/>	
<br/>	private static AccessToken ACCESS_TOKEN;
<br/>	
<br/>	/**
<br/>	 * Spring Injected
<br/>	 */
<br/>
<br/>	private RestTemplate restTemplate;
<br/>	
<br/>	private CustomerSightLoginService customerSightLoginService; 
<br/>	
<br/>	private RESTAuditLog restAuditLog;
<br/>	
<br/>	@Override
<br/>	public Response&lt;String&gt; execute(AbstractLoggedInCSRequest&lt;T&gt; request)
<br/>			throws RestConnectionException {
<br/>		throw new UnsupportedOperationException();
<br/>	}
<br/>
<br/>	/** (non-Javadoc)
<br/>	 * @see com.nri.xenos.inf.ext.Connection#execute()
<br/>	 */
<br/>	@Override
<br/>	public final Response&lt;String&gt; execute(Connection conn, AbstractLoggedInCSRequest&lt;T&gt; requestObject) throws RestConnectionException {
<br/>
<br/>		String response = null;
<br/>
<br/>		try{
<br/>			
<br/>			String enterprise = Application.getInstance().getContext().getEnterprise().getEnterpriseId();
<br/>			RefEnterpriseConfiguration refEnterpriseConfiguration = new RefEnterpriseConfiguration();
<br/>			
<br/>			int retryCount = 1;
<br/>			int maxRetryCount = Integer.parseInt(refEnterpriseConfiguration.getValue(conn, &#34;CS_LOGIN_MAX_RETRY&#34;));
<br/>			String authDateFormat = refEnterpriseConfiguration.getValue(conn, &#34;CS_LOGIN_AUTH_RESPONSE_DATE_FORMAT&#34;);
<br/>			
<br/>			StringBuffer sb = new StringBuffer(Globals.STRING_BUFFER_SIZE_SMALL);
<br/>			sb.append(refEnterpriseConfiguration.getValue(conn, &#34;CS_LOGIN_USERNAME&#34;)).append(Globals.COLON_SEPARATOR);
<br/>			sb.append(refEnterpriseConfiguration.getValue(conn, &#34;CS_LOGIN_PASSWORD&#34;)).append(Globals.COLON_SEPARATOR);
<br/>			sb.append(refEnterpriseConfiguration.getValue(conn, &#34;CS_HEADER_API_KEY&#34;));
<br/>			
<br/>			String credentials = sb.toString();
<br/>
<br/>			AbstractCSRequest&lt;MultiValueMap&lt;String, String&gt;&gt; loginRequest = customerSightLoginService.createRequest();
<br/>
<br/>			while(retryCount &lt;= maxRetryCount){
<br/>				if(ACCESS_TOKEN != null){
<br/>					if(isTokenValid(ACCESS_TOKEN)){
<br/>						try{
<br/>							response = request(requestObject, loginRequest, ACCESS_TOKEN.getToken());
<br/>							break;
<br/>						} catch(RestConnectionException ex){
<br/>							LOGGER.error(&#34;Trying &#34; + retryCount + &#34; times, error occured:&#34;, ex);
<br/>							if(retryCount == maxRetryCount){
<br/>								throw ex;
<br/>							}else{
<br/>								getTokenFromDatabase(conn, loginRequest, enterprise, Constants.REST_ACCOUNT_CUSTOMER_SIGHT, credentials, authDateFormat);
<br/>								retryCount++;
<br/>							}
<br/>						}
<br/>					}else{
<br/>						getTokenFromDatabase(conn, loginRequest, enterprise, Constants.REST_ACCOUNT_CUSTOMER_SIGHT, credentials, authDateFormat);
<br/>						retryCount++;
<br/>					}
<br/>				}else{
<br/>					getTokenFromDatabase(conn, loginRequest, enterprise, Constants.REST_ACCOUNT_CUSTOMER_SIGHT, credentials, authDateFormat);
<br/>					retryCount++;
<br/>				}
<br/>			}
<br/>		}
<br/>		catch(RestConnectionException ex) {
<br/>			throw ex;
<br/>		}
<br/>		catch (Exception e){
<br/>			LOGGER.error(&#34;Exception occured during connect to Customer Sight&#34;, e);
<br/>			throw new RestConnectionException(&#34;itf.error.cs.fail.send.fixml.unexpected&#34;);
<br/>			
<br/>		}
<br/>		
<br/>		if(response==null){
<br/>		//could not obtain valid token
<br/>			throw new RestConnectionException(&#34;itf.error.cs.fail.no.response.send.fixml&#34;);
<br/>		}
<br/>
<br/>		return new Response&lt;String&gt;(response);
<br/>	}
<br/>	
<br/>	/**
<br/>	 * This API check the access token is valid or not. &lt;code&gt;true&lt;/code&gt; if
<br/>	 * valid, &lt;code&gt;false&lt;/code&gt; otherwise.
<br/>	 * 
<br/>	 * @param accessToken
<br/>	 *            the access token object to compare, must not be
<br/>	 *            &lt;code&gt;null&lt;/code&gt;
<br/>	 * @return &lt;code&gt;true&lt;/code&gt; if valid, &lt;code&gt;false&lt;/code&gt; otherwise
<br/>	 * @throws RestConnectionException
<br/>	 *             if accessToken is &lt;code&gt;null&lt;/code&gt;
<br/>	 */
<br/>	private boolean isTokenValid(AccessToken accessToken) throws RestConnectionException {
<br/>		if(accessToken.getExpireTime() == null){
<br/>			LOGGER.error(&#34;Expire time is not present in Access Token&#34;);
<br/>			throw new RestConnectionException(&#34;Expire time is not present in Access Token&#34;);
<br/>		}
<br/>		return Calendar.getInstance().getTime().before(accessToken.getExpireTime());
<br/>	}
<br/>	
<br/>	/**
<br/>	 * Lock the database row, and get the token from database. If database token
<br/>	 * is expired then get the token from external system, then updates the
<br/>	 * database and local cache with new token
<br/>	 * 
<br/>	 * @param conn
<br/>	 * @param loginRequest
<br/>	 * @param enterpriseId
<br/>	 * @param extSysId
<br/>	 * @param extSysCredential
<br/>	 * @throws RestConnectionException
<br/>	 */
<br/>	private void getTokenFromDatabase(Connection conn, AbstractCSRequest&lt;MultiValueMap&lt;String, String&gt;&gt; loginRequest,
<br/>			String enterpriseId, String extSysId, String extSysCredential, String authDateFormat)
<br/>					throws RestConnectionException {
<br/>
<br/>		JsonElement responseJson = null;
<br/>
<br/>		try{
<br/>			
<br/>			List results = lock(conn, enterpriseId, extSysId, extSysCredential);
<br/>			validateResult(results);
<br/>			ExtSysLock extSysLock = (ExtSysLock) results.get(0);
<br/>			if(extSysLock.getExtSysAuthToken() == null || extSysLock.getExtSysTokenExpireTime() == null){
<br/>				responseJson = login(loginRequest);
<br/>				ACCESS_TOKEN = new AccessToken(getAccessToken(responseJson), getExpireTime(responseJson, authDateFormat));
<br/>				updateToken(conn, getAccessToken(responseJson), getExpireTime(responseJson, authDateFormat), enterpriseId, extSysId, extSysCredential);
<br/>			}else{
<br/>				ACCESS_TOKEN = new AccessToken(extSysLock.getExtSysAuthToken(), extSysLock.getExtSysTokenExpireTime());
<br/>				if(!isTokenValid(ACCESS_TOKEN)){
<br/>					responseJson = login(loginRequest);
<br/>					ACCESS_TOKEN = new AccessToken(getAccessToken(responseJson), getExpireTime(responseJson, authDateFormat));
<br/>					updateToken(conn, getAccessToken(responseJson), getExpireTime(responseJson, authDateFormat), enterpriseId, extSysId, extSysCredential);
<br/>				}
<br/>			}
<br/>		} catch (SQLException e) {
<br/>			LOGGER.error(&#34;Failed to get token of Customer Sight from database&#34;, e);
<br/>			throw new RestConnectionException(e);
<br/>		}
<br/>	}
<br/>	
<br/>	/**
<br/>	 * Lock the row with ROW SELECT FOR UPDATE strategy
<br/>	 * 
<br/>	 * @param conn
<br/>	 *            database connection
<br/>	 * @param enterpriseId
<br/>	 *            the enterprise id
<br/>	 * @param extSysId
<br/>	 *            external system id
<br/>	 * @param credential
<br/>	 *            credentials
<br/>	 * @return the locked record
<br/>	 * @throws SQLException
<br/>	 *             if any exception occurs
<br/>	 */
<br/>	private List lock(Connection conn, String enterpriseId, String extSysId, String credential) throws SQLException{
<br/>		
<br/>		StringBuffer sb = new StringBuffer(Globals.STRING_BUFFER_SIZE_MEDIUM);
<br/>		
<br/>		sb.append(&#34; SELECT ext_sys_auth_token, &#34;);
<br/>		sb.append(&#34;   ext_sys_token_expire_time &#34;);
<br/>		sb.append(&#34; FROM ref_ext_sys_lock &#34;);
<br/>		sb.append(&#34;  WHERE enterprise_id = &#34; + com.nri.xenos.inf.dbutils.DbUtils.enquoteString(enterpriseId));
<br/>		sb.append(&#34;  and ext_sys_credential = &#34; + com.nri.xenos.inf.dbutils.DbUtils.enquoteString(credential));
<br/>		sb.append(&#34;  and ext_sys_id = &#34; + com.nri.xenos.inf.dbutils.DbUtils.enquoteString(extSysId));
<br/>		sb.append(&#34; FOR UPDATE &#34;);
<br/>		
<br/>		return QueryBuilderUtils.query(conn, sb.toString(), ExtSysLock.class, null, 0);
<br/>	}
<br/>
<br/>	private String request(AbstractLoggedInCSRequest&lt;T&gt; requestObject,
<br/>			AbstractCSRequest&lt;MultiValueMap&lt;String, String&gt;&gt; loginRequest, String accessToken) throws RestConnectionException {
<br/>		
<br/>		String response = null;
<br/>		
<br/>		requestObject.setHeaderApiKey(loginRequest.getHeaderApiKey());
<br/>		requestObject.setHeaderEnterpriseId(loginRequest.getHeaderEnterpriseId());
<br/>		requestObject.setAccessToken(accessToken);
<br/>		
<br/>		try {
<br/>			restAuditLog.getRestAuditLogBean().setRequestTime(Calendar.getInstance().getTime());
<br/>			restAuditLog.getRestAuditLogBean().setEnterpriseId(Application.getInstance().getContext().getEnterprise().getEnterpriseId());
<br/>			restAuditLog.getRestAuditLogBean().setDestinationSystem(Constants.REST_ACCOUNT_CUSTOMER_SIGHT);
<br/>			restAuditLog.getRestAuditLogBean().setReferenceNo(requestObject.getRequestId());
<br/>			restAuditLog.getRestAuditLogBean().setRequestPayload(requestObject.getBody().toString());
<br/>			
<br/>			response = processRequest(requestObject);
<br/>			
<br/>			restAuditLog.getRestAuditLogBean().setResponsePayload(response);
<br/>			restAuditLog.getRestAuditLogBean().setResponseTime(Calendar.getInstance().getTime());
<br/>		} finally {
<br/>			// Call logAuditInfo() to save request and response info in db
<br/>			restAuditLog.logAuditInfo();
<br/>		}
<br/>		return response;
<br/>	}
<br/>
<br/>	@SuppressWarnings({ &#34;rawtypes&#34;, &#34;unchecked&#34; })
<br/>	private JsonElement login(AbstractCSRequest loginRequest ) throws RestConnectionException {
<br/>		JsonElement jsonResponse = null;
<br/>		//login
<br/>		try {
<br/>			restAuditLog.getRestAuditLogBean().setRequestTime(Calendar.getInstance().getTime());
<br/>			restAuditLog.getRestAuditLogBean().setEnterpriseId(Application.getInstance().getContext().getEnterprise().getEnterpriseId());
<br/>			restAuditLog.getRestAuditLogBean().setDestinationSystem(Constants.REST_ACCOUNT_CUSTOMER_SIGHT);
<br/>			restAuditLog.getRestAuditLogBean().setRequestPayload(loginRequest.getBody().toString());
<br/>
<br/>			String jsonBody =  processRequest(loginRequest);
<br/>
<br/>			restAuditLog.getRestAuditLogBean().setResponsePayload(jsonBody);
<br/>			restAuditLog.getRestAuditLogBean().setResponseTime(Calendar.getInstance().getTime());
<br/>
<br/>			if(LOGGER.isDebugEnabled()){
<br/>				LOGGER.debug(&#34;Response received on login : &#34; +jsonBody);	
<br/>			}
<br/>
<br/>			JsonParser jsonParser = new JsonParser();
<br/>			jsonResponse = jsonParser.parse(jsonBody);
<br/>		}
<br/>		finally {
<br/>			// Call logAuditInfo() to save request and response info in db
<br/>			restAuditLog.logAuditInfo();
<br/>		}
<br/>
<br/>		return jsonResponse;
<br/>
<br/>	}
<br/>
<br/>	/**
<br/>	 * Get the access token from JsonElement object
<br/>	 * 
<br/>	 * @param jsonResponse
<br/>	 * @return
<br/>	 * @throws RestConnectionException
<br/>	 */
<br/>	private String getAccessToken(JsonElement jsonResponse) throws RestConnectionException {
<br/>		JsonElement jsonElement = jsonResponse.getAsJsonObject().get(&#34;access_token&#34;);
<br/>		if(jsonElement==null){
<br/>			LOGGER.debug(&#34;Login Access token not found&#34;);
<br/>			throw new RestConnectionException(&#34;Login Access token not found&#34;);
<br/>		}
<br/>		return jsonElement.getAsString();
<br/>	}
<br/>	
<br/>	/**
<br/>	 * Get the expire time from JsonElement object
<br/>	 * 
<br/>	 * @param jsonResponse
<br/>	 * @return
<br/>	 * @throws RestConnectionException
<br/>	 *             if expire time not found in json body or if failed to parse the date
<br/>	 */
<br/>	private Date getExpireTime(JsonElement jsonResponse, String authDateFormat) throws RestConnectionException {
<br/>		JsonElement jsonElement = jsonResponse.getAsJsonObject().get(&#34;.expires&#34;);
<br/>		if(jsonElement==null){
<br/>			LOGGER.debug(&#34;Login expire time not found&#34;);
<br/>			throw new RestConnectionException(&#34;Login expire time not found&#34;);
<br/>		}
<br/>		Date expireTime = null;
<br/>		SimpleDateFormat sdf = new SimpleDateFormat(authDateFormat);
<br/>		try {
<br/>			expireTime = sdf.parse(jsonElement.getAsString());
<br/>		} catch (ParseException e) {
<br/>			LOGGER.debug(&#34;Failed to parse Login Expire Time&#34;, e);
<br/>			throw new RestConnectionException(&#34;Failed to parse Login Expire Time&#34;, e);
<br/>		}
<br/>		return expireTime;
<br/>	}
<br/>
<br/>
<br/>	@SuppressWarnings({ &#34;unchecked&#34;, &#34;rawtypes&#34; })
<br/>	private String processRequest(AbstractCSRequest&lt;T&gt; loginRequest) throws RestConnectionException {
<br/>		
<br/>		HttpEntity request = new HttpEntity(loginRequest.getBody(),loginRequest.getHeaderRequests());
<br/>		
<br/>		if(LOGGER.isDebugEnabled()){
<br/>			
<br/>			LOGGER.debug(&#34;Http Headers : &#34; + loginRequest.getHeaderRequests());
<br/>			LOGGER.debug(&#34;Http Body : &#34; + loginRequest.getBody());
<br/>			
<br/>		}
<br/>		
<br/>		Class&lt;? extends AbstractCSRequest&gt; requestClass = loginRequest.getClass();
<br/>		Endpoint annotation = requestClass.getAnnotation(Endpoint.class);
<br/>		String requestURL = annotation.url();
<br/>		HttpMethod httpMethod = annotation.method();
<br/>		ResponseEntity&lt;String&gt; responseEntity = null;
<br/>		try{
<br/>		
<br/>			switch(httpMethod){
<br/>			
<br/>				case POST:
<br/>					
<br/>					responseEntity = restTemplate.postForEntity(getEndpoint(requestURL), request, String.class);
<br/>					break;
<br/>				case GET:
<br/>					responseEntity = restTemplate.getForEntity(getEndpoint(requestURL),String.class);
<br/>					break;
<br/>					
<br/>				default:
<br/>					break;
<br/>							
<br/>			}	
<br/>		}catch(HttpClientErrorException e){
<br/>			restAuditLog.getRestAuditLogBean().setHttpResponseCode((long) e.getStatusCode().value());
<br/>			
<br/>			// get the message for the respective HTTP code for failure case
<br/>			// set the code and message
<br/>			// throw RestConnectionException for all the failure cases
<br/>			LOGGER.error(&#34;HTTP host error,connection could not be established with Customer Sight&#34;,e);
<br/>			
<br/><del>		
</del><br/><ins>			//if()
</ins><br/><ins>				//itf.error.cs.fail.invalid.authorization.send.fixml.errorcode
</ins><br/>			if(e.getStatusCode().value()==400) {
<br/>				errorCode = &#34;itf.error.cs.fail.invalid.token.send.fixml.errorcode&#34;;
<br/>			}else if(e.getStatusCode().value()==401) {
<br/>				errorCode = &#34;itf.error.cs.fail.invalid.authorization.send.fixml.errorcode&#34;;
<br/>			}
<br/>			RestConnectionException connectionException = new RestConnectionException(errorCode);
<br/>			//connectionException.setErrorCode(errorCode);
<br/>			connectionException.setErrorCode(e.getStatusCode().value());
<br/>			connectionException.setErrorDescription(e.getStatusText());
<br/>			connectionException.setResponseBody(e.getResponseBodyAsString());
<br/>			throw connectionException;
<br/>			
<br/>		}catch(RestClientException e){
<br/>			LOGGER.error(&#34;Connection could not be established with Customer Sight&#34;,e);
<br/>			throw new RestConnectionException(&#34;itf.error.cs.fail.send.fixml.unexpected&#34;);
<br/>		}
<br/>		
<br/>		if(responseEntity ==  null){
<br/>			LOGGER.error(&#34;No response received from Customer Sight&#34;);
<br/>			throw new RestConnectionException(&#34;itf.error.cs.fail.no.response.send.fixml&#34;);
<br/>		}
<br/>		
<br/>		if(responseEntity.getStatusCode()!=HttpStatus.OK){
<br/>			
<br/>			// get the message for the respective HTTP code for failure case
<br/>			// set the code and message
<br/>			// throw RestConnectionException for all the failure cases
<br/>			String statusText = org.apache.commons.httpclient.HttpStatus.getStatusText(responseEntity.getStatusCode().value());
<br/>			LOGGER.error(&#34;Received Error: &#34; + responseEntity.getStatusCode().name() + &#34; Status Text: &#34; + statusText + &#34; Error Body: &#34; + responseEntity.getBody());
<br/>			RestConnectionException connectionException = new RestConnectionException(&#34;itf.error.cs.fail.send.fixml&#34;);
<br/>			connectionException.setErrorCode(responseEntity.getStatusCode().value());
<br/>			connectionException.setErrorDescription(statusText);
<br/>			
<br/>			restAuditLog.getRestAuditLogBean().setHttpResponseCode(Long.parseLong(responseEntity.getStatusCode().toString()));
<br/>			restAuditLog.getRestAuditLogBean().setResponsePayload(responseEntity.getBody());
<br/>			restAuditLog.getRestAuditLogBean().setResponseTime(Calendar.getInstance().getTime());
<br/>			
<br/>			throw connectionException;
<br/>			
<br/>		}
<br/>		
<br/>		restAuditLog.getRestAuditLogBean().setHttpResponseCode(Long.parseLong(responseEntity.getStatusCode().toString()));
<br/>		return responseEntity.getBody();
<br/>	}
<br/>
<br/>
<br/>	/* (non-Javadoc)
<br/>	 * @see com.nri.xenos.th.settrade.SETOperation#getEndpoint()
<br/>	 */
<br/>	private URI getEndpoint(String url) throws RestConnectionException {
<br/>		
<br/>		StringBuilder endpoint = new StringBuilder();
<br/>		
<br/>		String basePath = getFromDB(&#34;CS_BASE_ENDPOINT&#34;);
<br/>		
<br/>		endpoint.append(basePath).append(url);
<br/>		
<br/>		LOGGER.debug(&#34;Customer Sight URL Called : &#34;+endpoint);
<br/>		
<br/>		restAuditLog.getRestAuditLogBean().setRequestUrl(endpoint.toString());
<br/>		
<br/>		return URI.create(endpoint.toString());			
<br/>	}
<br/>	
<br/>
<br/>	/**
<br/>	 * @param string
<br/>	 * @return
<br/>	 */
<br/>	private String getFromDB(String key) throws RestConnectionException {
<br/>		
<br/>		RefEnterpriseConfiguration refEnterpriseConfiguration = new RefEnterpriseConfiguration();
<br/>		
<br/>		java.sql.Connection conn = null;
<br/>		try {
<br/>			conn = Application.getInstance().getJdbcConnectionFactory().newConnection(Module.REF);
<br/>			return refEnterpriseConfiguration.getValue(conn, key); 
<br/>		} catch (SQLException  e) {
<br/>			throw new RestConnectionException(e);
<br/>		}finally{
<br/>			DbUtils.closeQuietly(conn);
<br/>		}		
<br/>	}
<br/>	
<br/>	/**
<br/>	 * Validates the result is empty or more than one. expectation is one record
<br/>	 * will be returned.
<br/>	 * 
<br/>	 * @param results
<br/>	 *            the result to validate
<br/>	 * @throws RestConnectionException
<br/>	 *             if no record or more than one record founds
<br/>	 */
<br/>	private void validateResult(List results) throws RestConnectionException {
<br/>		if(results == null || results.isEmpty()){
<br/>			LOGGER.error(&#34;No records found in the database&#34;);
<br/>			throw new RestConnectionException(&#34;No records found in the database&#34;);
<br/>		}
<br/>		if(results.size() &gt; 1){
<br/>			LOGGER.error(&#34;More than one record found in the database&#34;);
<br/>			throw new RestConnectionException(&#34;More than one record found in the database&#34;);
<br/>		}
<br/>	}
<br/>	
<br/>	/**
<br/>	 * Update the token and expire time in database
<br/>	 * 
<br/>	 * @param conn
<br/>	 * @param token
<br/>	 * @param expireTime
<br/>	 * @param enterpriseId
<br/>	 * @param extSysId
<br/>	 * @param credential
<br/>	 * @throws SQLException
<br/>	 */
<br/>	protected void updateToken(Connection conn, String token, Date expireTime, 
<br/>			String enterpriseId, String extSysId, String credential) throws SQLException {
<br/>		
<br/>		StringBuilder sqlSB = new StringBuilder(Globals.STRING_BUFFER_SIZE_BIG);
<br/>		String updatedBy = Application.getInstance().getContext().getCallerIdentity().getName();
<br/>
<br/>		sqlSB.append(&#34;UPDATE  &#34;);
<br/>		sqlSB.append(&#34; REF_EXT_SYS_LOCK &#34;);
<br/>		sqlSB.append(&#34; SET  &#34;);
<br/>		sqlSB.append(&#34; EXT_SYS_AUTH_TOKEN = &#34;);
<br/>		sqlSB.append(com.nri.xenos.inf.dbutils.DbUtils.enquoteString(token));
<br/>		sqlSB.append(&#34; , EXT_SYS_TOKEN_EXPIRE_TIME = &#34;);
<br/>		sqlSB.append(com.nri.xenos.inf.dbutils.DbUtils.getSqlDateString(expireTime));
<br/>		
<br/>		sqlSB.append(&#34; , UPDATED_BY = &#34;);
<br/>		sqlSB.append(com.nri.xenos.inf.dbutils.DbUtils.enquoteString(updatedBy));
<br/>		sqlSB.append(&#34; , UPDATE_DATE = &#34;);
<br/>		sqlSB.append(&#34; SYSDATE &#34;);
<br/>		
<br/>		sqlSB.append(&#34; where &#34;);
<br/>		sqlSB.append(&#34;  enterprise_id = &#34;).append(com.nri.xenos.inf.dbutils.DbUtils.enquoteString(enterpriseId));
<br/>		sqlSB.append(&#34;  and ext_sys_credential = &#34;).append(com.nri.xenos.inf.dbutils.DbUtils.enquoteString(credential));
<br/>		sqlSB.append(&#34;  and ext_sys_id = &#34;).append(com.nri.xenos.inf.dbutils.DbUtils.enquoteString(extSysId));
<br/>
<br/>		String sql = sqlSB.toString();
<br/>		LOGGER.debug(&#34;Executing update: &#34; +  sql);
<br/>
<br/>		int count = QueryBuilderUtils.update(conn, sql);
<br/>		if(count == 0) {
<br/>			String errorMsg = &#34;There is no record with specified primary key&#34;;
<br/>			LOGGER.error(errorMsg);
<br/>			throw new NoRecordFoundException(errorMsg);
<br/>		}
<br/>		LOGGER.debug(&#34;Updated &#34; + count + &#34; rows&#34;);
<br/>	}
<br/>	
<br/>	public void setRestTemplate(RestTemplate restTemplate) {
<br/>		this.restTemplate = restTemplate;
<br/>	}
<br/>
<br/>
<br/>	public void setCustomerSightLoginService(CustomerSightLoginService customerSightLoginService) {
<br/>		this.customerSightLoginService = customerSightLoginService;
<br/>	}
<br/>
<br/>	/**
<br/>	 * @param restAuditLog the restAuditLog to set
<br/>	 */
<br/>	public void setRestAuditLog(RESTAuditLog restAuditLog) {
<br/>		this.restAuditLog = restAuditLog;
<br/>	}
<br/>
<br/>}
<br/>
<br/>
</body></html>
Time taken :  47.6671ms
